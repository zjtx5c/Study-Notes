## 语法

* 结构化绑定是 C++17 引入的一种语法糖，目的是让你可以“**同时声明多个变量**，并直接从 tuple、pair、结构体中**解包**”。

  结构化绑定就是 C++ 的“解包”语法，让你能直接从 `pair/tuple/struct` 里取出多个值，不再写 `.first`、`.second`，但 **默认会拷贝，需要加 `&` 才是引用**！

  * eg

  不用结构化绑定

  ```c++
  std::pair<int, std::string> p = {42, "hello"};
  int a = p.first;
  std::string b = p.second;
  ```

  可以看出来非常啰嗦，如果使用结构化绑定，则

  ```c++
  # 这里仅仅是拷贝
  auto [a, b] = p;
  ```

  如果想要“**引用原来的内容**”，就要这么写：

  ```c++
  auto& [a, b] = p;
  ```

  不会产生拷贝，适用于**大型对象、需要修改原数据等场景**（对象很大，且需要修改推荐使用）。

  仅只读建议拷贝，但大型对象不建议拷贝，因为会占据内存；若要修改就一定要用引用了







## 其他

### **默认构造行为**和**空容器访问**的细节

* `std::map<int, std::set<int>>` 的情况，**即对映射创建一个只有键而没有值是什么情况**

```c++
#include <bits/stdc++.h>

int main() {
    std::map<int, std::set<int>> st;
    st[1].insert(2);
    std::cout << st.size() << '\n';

    // 显示声明一个键，默认就是空
    st[2];
    std::cout << st.size() << '\n';

    for (auto& [k, v] : st) {
        std::cout << k * 3 << "--------" << '\n';
        std::cout << v.size() << '\n';
    }
    return 0;
}

/*
输出
1
2
3--------
1
6--------
0（这里的 0 不知道是什么意思，不管）
*/

```

可以发现，这种情况下，键能访问，但是值为空

以下是一些默认构造

| 类型             | 默认构造的值（`T{}` 或 `T()`） |
| ---------------- | ------------------------------ |
| `int`            | `0`                            |
| `double`         | `0.0`                          |
| `bool`           | `false`                        |
| `std::set<T>`    | **空**集合 `{}`                |
| `std::string`    | **空**字符串 `""`              |
| `std::vector<T>` | **空**向量 `[]`                |

针对这些**空**的情况，直接访问是比较危险的，并不建议这样做。
