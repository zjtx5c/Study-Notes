## 语法

### 理解 `const`

`const` 表示这两个参数 **在函数体内不会被修改**。

在 C++ 中，传引用（`&`）虽然可以避免对象拷贝带来的开销（尤其是结构体、类等复杂类型），但是默认是可以修改引用指向的对象的。加上 `const`，就表示：

- 我只是**读取**这个参数，
- **绝对不会修改它的内容**。

#### 使用 `const` 的好处

**安全性提升**：

- 函数内部不小心写了 `a.max = 5;` 这样的代码，编译器会报错，避免误修改参数。

**语义更清晰**：

- 表示“这个函数只是用 `a` 和 `b` 来计算结果，不修改它们”。

**可以接受 `const` 参数**：

- ~~如果你传给这个函数的 `a` 或 `b` 是一个 `const Info` 类型的变量，那只有这个版本的函数才能接受，否则会报错。~~

**遵循 C++ 最佳实践**：

- 对于传引用且不会修改的参数，加 `const` 是**写高质量代码的基本习惯。**



### 结构化绑定

结构化绑定是 C++17 引入的一种语法糖，目的是让你可以“**同时声明多个变量**，并直接从 tuple、pair、结构体中**解包**”。

结构化绑定就是 C++ 的“解包”语法，让你能直接从 `pair/tuple/struct` 里取出多个值，不再写 `.first`、`.second`，但 **默认会拷贝，需要加 `&` 才是引用**！

* eg

不用结构化绑定

```c++
std::pair<int, std::string> p = {42, "hello"};
int a = p.first;
std::string b = p.second;
```

可以看出来非常啰嗦，如果使用结构化绑定，则

```c++
# 这里仅仅是拷贝
auto [a, b] = p;
```

如果想要“**引用原来的内容**”，就要这么写：

```c++
auto& [a, b] = p;
```

不会产生拷贝，适用于**大型对象、需要修改原数据等场景**（对象很大，且需要修改推荐使用）。

仅只读建议拷贝，但大型对象不建议拷贝，因为会占据内存；若要修改就一定要用引用了



###  关于对象的构造函数

* 构造函数名称与参数
* 初始化列表
  * 它用来初始化类成员变量

理解一下以下代码

```cpp
SegmentTree(int n_) : n(n_), tag(4 * n), info(4 * n) {}
```



### `T{}`

* 这是 C++11 引入的 **统一初始化语法（Uniform Initialization Syntax）**，`T{}` 表示用 **值初始化（value initialization）** 的方式构造一个 `T` 类型的对象。

在此之前我们使用了 `template <typename T>`

```c++
vector<int> a;
a.assign(5, int{});  // 就是 [0, 0, 0, 0, 0]

vector<string> b;
b.assign(3, string{});  // 就是 ["", "", ""]

vector<pair<int, double>> c;
c.assign(2, pair<int, double>{});  // 就是 [(0, 0.0), (0, 0.0)]

```

* `T{}` 会触发**值初始化**

  - 如果是内置类型（int、double 等）→ 变成 `0`

  - 如果是类/struct → 调用默认构造函数

* 能写 `T{}` 是因为 C++ 允许你使用 **花括号初始化一个类型的默认值**，它是 **构造一个默认值的合法方式**，语法非常泛化、强大、安全 —— 这是现代 C++ 的一个核心特性。



## 容器

### vector

#### `.assign()`

`.assign` 是 C++ 标准库中 `std::vector` 的一个成员函数，用于**将指定值填充到向量中**，或者**将另一个容器的元素拷贝到当前向量中**。

* 将指定值填充到向量中

  ```cpp
  vec.assign(n, value)
  ```

  这里 `n` 是填充的元素个数，`value` 是填充到每个位置的值。

* 将另一个容器的元素拷贝到当前向量

  ```c++
  vec2.assign(vec1.begin(), vec1.end())
  ```



#### `.resize()`

`std::vector` 的 `.resize()` 是一个成员函数，用于**改变向量的大小**。它可以通过调整向量的大小来添加或删除元素。

* 改变向量大小

  ```c++
  vec.resize(new_size);
  ```

  **`new_size`**：是你想要改变的新的大小。

  如果新的大小比原来的大，`resize` 会通过默认构造值（例如对于 `int` 类型是 `0`）来扩展向量。

  如果新的大小比原来的小，向量的末尾元素会被删除。

* 指定新的大小和默认值

  ```c++
  vec.resize(new_size, value)
  ```

  **`new_size`**：新大小。

  **`value`**：新增元素的默认值。若 `new_size` 大于原来大小，则新增的元素都会被初始化为 `value`。



## 数值处理

### numeric

`<numeric>` 是 C++ 标准库中的头文件，专门包含**数值处理**相关的函数模板。虽然不像 `<algorithm>` 那么丰富，但它提供了一些很实用的工具，特别适合用于数值型容器（如 `std::vector`）的处理。

| 函数                                                    | 简介                                |
| ------------------------------------------------------- | ----------------------------------- |
| `std::accumulate`                                       | **求和/通用聚合**（可以自定义操作） |
| `std::reduce` (C++17)                                   | 类似 `accumulate`，但可能并行执行   |
| `std::inner_product`                                    | **内积/点积**（也可自定义）         |
| `std::adjacent_difference`                              | 相邻元素差值输出                    |
| `std::partial_sum`                                      | 前缀和计算（也可自定义操作）        |
| `std::exclusive_scan` / `std::inclusive_scan` (C++17)   | 高级前缀操作，适用于并行计算        |
| `std::transform_reduce` / `std::transform_scan` (C++17) | 结合 `transform` 和 `reduce/scan`   |

​	

#### `.accumulate()`

累加操作

```cpp
#include <numeric>
std::accumulate(v.begin(), v.end(), 0);
```



## 其他

### **默认构造行为**和**空容器访问**的细节

* `std::map<int, std::set<int>>` 的情况，**即对映射创建一个只有键而没有值是什么情况**

```c++
#include <bits/stdc++.h>

int main() {
    std::map<int, std::set<int>> st;
    st[1].insert(2);
    std::cout << st.size() << '\n';

    // 显示声明一个键，默认就是空
    st[2];
    std::cout << st.size() << '\n';

    for (auto& [k, v] : st) {
        std::cout << k * 3 << "--------" << '\n';
        std::cout << v.size() << '\n';
    }
    return 0;
}

/*
输出
1
2
3--------
1
6--------
0（这里的 0 不知道是什么意思，不管）
*/

```

可以发现，这种情况下，键能访问，但是值为空

以下是一些默认构造

| 类型             | 默认构造的值（`T{}` 或 `T()`） |
| ---------------- | ------------------------------ |
| `int`            | `0`                            |
| `double`         | `0.0`                          |
| `bool`           | `false`                        |
| `std::set<T>`    | **空**集合 `{}`                |
| `std::string`    | **空**字符串 `""`              |
| `std::vector<T>` | **空**向量 `[]`                |

针对这些**空**的情况，直接访问是比较危险的，并不建议这样做。
